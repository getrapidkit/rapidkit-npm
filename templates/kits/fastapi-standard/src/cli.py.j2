#!/usr/bin/env python3
"""Professional CLI commands for {{ project_name }} - Poetry Scripts Integration

A modern CLI inspired by Next.js developer experience for FastAPI projects.
"""

import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict


def _print_banner(emoji: str, message: str, color_code: str = "36") -> None:
    """Print colored banner message."""
    print(f"\033[{color_code}m{emoji} {message}\033[0m")


def _print_error(message: str) -> None:
    """Print error message in red."""
    print(f"\033[91mâŒ {message}\033[0m")


def _print_success(message: str) -> None:
    """Print success message in green."""
    print(f"\033[92mâœ… {message}\033[0m")


def _get_env_var(key: str, default: str) -> str:
    """Get environment variable with default."""
    return os.getenv(key, default)


def _parse_args() -> dict:
    """Parse command line arguments."""
    args = {"port": "8000", "host": "0.0.0.0", "workers": "1", "env": "development"}

    i = 0
    while i < len(sys.argv):
        if sys.argv[i] in ["--port", "-p"] and i + 1 < len(sys.argv):
            args["port"] = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] in ["--host", "-h"] and i + 1 < len(sys.argv):
            args["host"] = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] in ["--workers", "-w"] and i + 1 < len(sys.argv):
            args["workers"] = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] in ["--env", "-e"] and i + 1 < len(sys.argv):
            args["env"] = sys.argv[i + 1]
            i += 2
        else:
            i += 1

    return args

def _run_uvicorn(module: str, reload: bool = False, **kwargs: Any) -> None:
    """Run uvicorn server with proper error handling."""
    args: Dict[str, Any] = _parse_args()

    cmd: list[str] = [
        sys.executable, "-m", "uvicorn",
        module,
        "--host", str(args.get("host", "0.0.0.0")),
        "--port", str(args.get("port", 8000))
    ]

    if reload:
        cmd.append("--reload")
        cmd.extend(["--reload-dir", "src"])

    env: str = args.get("env", "development")
    if env == "production" and "workers" in args:
        cmd.extend(["--workers", str(args["workers"])])
        cmd.append("--no-access-log")

    extra_args: list[str] = kwargs.get("extra_args", [])
    cmd.extend(extra_args)

    env_vars: Dict[str, str] = os.environ.copy()
    env_vars.update({
        "PYTHONPATH": str(Path.cwd()),
        "ENVIRONMENT": env
    })

    try:
        subprocess.run(cmd, check=False, env=env_vars)
    except KeyboardInterrupt:
        _print_banner("ðŸ›‘", "Server stopped by user")
    except Exception as e:
        _print_error(f"Failed to start server: {e}")
        sys.exit(1)

def dev() -> None:
    """ðŸš€ Start development server with hot reload

    Usage:
        poetry run dev [options]

    Options:
        --port, -p PORT     Server port (default: 8000)
        --host, -h HOST     Server host (default: 0.0.0.0)
        --env, -e ENV       Environment (default: development)

    Examples:
        poetry run dev
        poetry run dev --port 3000
        poetry run dev --host 127.0.0.1 --port 8080
    """
    _print_banner("ðŸš€", "Starting development server with hot reload...")
    _print_banner("ðŸ“", f"Working directory: {Path.cwd()}")

    args = _parse_args()
    _print_banner("ðŸŒ", f"Server will be available at: http://{args['host']}:{args['port']}")

    _run_uvicorn("src.main:app", reload=True)


def start() -> None:
    """âš¡ Start production server

    Usage:
        poetry run start [options]

    Options:
        --port, -p PORT     Server port (default: 8000)
        --host, -h HOST     Server host (default: 0.0.0.0)
        --workers, -w NUM   Number of workers (default: 1)

    Examples:
        poetry run start
        poetry run start --workers 4 --port 80
    """
    _print_banner("âš¡", "Starting production server...")

    args = _parse_args()
    _print_banner("ðŸ‘¥", f"Workers: {args['workers']}")
    _print_banner("ðŸŒ", f"Server will be available at: http://{args['host']}:{args['port']}")

    _run_uvicorn("src.main:app", reload=False, env="production")


def build() -> None:
    """ðŸ“¦ Build project for production

    This command prepares the project for production deployment:
    - Validates dependencies
    - Runs type checking
    - Builds distribution packages
    """
    _print_banner("ðŸ“¦", "Building project for production...")

    try:
        # Type checking
        _print_banner("ðŸ”", "Running type checks...")
        result = subprocess.run([
            sys.executable, "-m", "mypy", "src", "--ignore-missing-imports"
        ], capture_output=True, text=True)

        if result.returncode != 0:
            _print_error("Type checking failed!")
            print(result.stdout)
            print(result.stderr)
        else:
            _print_success("Type checking passed!")

        # Build wheel
        _print_banner("ðŸ—ï¸", "Building distribution packages...")
        subprocess.run([sys.executable, "-m", "build"], check=True)

        _print_success("Build completed successfully!")
        _print_banner("ðŸ“", "Distribution files created in 'dist/' directory")

    except subprocess.CalledProcessError as e:
        _print_error(f"Build failed: {e}")
        sys.exit(1)
    except FileNotFoundError:
        _print_error("Build tools not found. Install with: poetry install --group dev")
        sys.exit(1)


def test() -> None:
    """ðŸ§ª Run tests with coverage

    Usage:
        poetry run test [pytest-options]

    Examples:
        poetry run test
        poetry run test -v
        poetry run test tests/test_api.py
        poetry run test --cov-report=html
    """
    _print_banner("ðŸ§ª", "Running tests with coverage...")

    # Get additional pytest args
    pytest_args = [arg for arg in sys.argv[2:] if not arg.startswith("-")]

    cmd = [
        sys.executable, "-m", "pytest",
        "--cov=src",
        "--cov-report=term-missing",
        "--cov-report=xml",
        "-v"
    ] + pytest_args

    try:
        result = subprocess.run(cmd, check=False)

        if result.returncode == 0:
            _print_success("All tests passed!")
        else:
            _print_error("Some tests failed!")
            sys.exit(result.returncode)

    except FileNotFoundError:
        _print_error("pytest not found. Install with: poetry install --group dev")
        sys.exit(1)


def lint() -> None:
    """ï¿½ Run code linting and formatting

    This command runs:
    - ruff for linting
    - black for formatting
    - isort for import sorting
    """
    _print_banner("ï¿½", "Running linting and formatting...")

    try:
        # Ruff linting
        _print_banner("ðŸ“‹", "Running ruff linter...")
        subprocess.run([sys.executable, "-m", "ruff", "check", "src"], check=True)

        # Black formatting
        _print_banner("ðŸŽ¨", "Running black formatter...")
        subprocess.run([sys.executable, "-m", "black", "src", "--check"], check=True)

        # isort import sorting
        _print_banner("ðŸ“¦", "Checking import sorting...")
        subprocess.run([sys.executable, "-m", "isort", "src", "--check-only"], check=True)

        _print_success("All linting checks passed!")

    except subprocess.CalledProcessError:
        _print_error("Linting failed! Run 'poetry run format' to fix issues.")
        sys.exit(1)
    except FileNotFoundError:
        _print_error("Linting tools not found. Install with: poetry install --group dev")
        sys.exit(1)


def format() -> None:
    """âœ¨ Format code automatically

    This command auto-fixes:
    - Code formatting with black
    - Import sorting with isort
    - Auto-fixable linting issues with ruff
    """
    _print_banner("âœ¨", "Formatting code...")

    try:
        # Ruff auto-fix
        _print_banner("ðŸ”§", "Auto-fixing with ruff...")
        subprocess.run([sys.executable, "-m", "ruff", "check", "src", "--fix"], check=True)

        # Black formatting
        _print_banner("ðŸŽ¨", "Formatting with black...")
        subprocess.run([sys.executable, "-m", "black", "src"], check=True)

        # isort import sorting
        _print_banner("ðŸ“¦", "Sorting imports with isort...")
        subprocess.run([sys.executable, "-m", "isort", "src"], check=True)

        _print_success("Code formatting completed!")

    except subprocess.CalledProcessError as e:
        _print_error(f"Formatting failed: {e}")
        sys.exit(1)
    except FileNotFoundError:
        _print_error("Formatting tools not found. Install with: poetry install --group dev")
        sys.exit(1)


def help_cmd() -> None:
    """ðŸ“š Show detailed help information"""
    _print_banner("ðŸ“š", "{{ project_name }} - Available Commands")

    commands = {
        "dev": "ðŸš€ Start development server with hot reload",
        "start": "âš¡ Start production server",
        "build": "ðŸ“¦ Build project for production",
        "test": "ðŸ§ª Run tests with coverage",
        "lint": "ðŸ”§ Run code linting and formatting checks",
        "format": "âœ¨ Format code automatically",
        "help": "ðŸ“š Show this help message"
    }

    print("\nCommands:")
    for cmd, desc in commands.items():
        print(f"  poetry run {cmd:<10} {desc}")

    print("\nFor detailed command help:")
    print("  poetry run <command> --help")

    print("\nProject: {{ project_name }}")
    print("Framework: FastAPI + RapidKit")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        help_cmd()
        sys.exit(0)

    command = sys.argv[1]
    commands = {
        "dev": dev,
        "start": start,
        "build": build,
        "test": test,
        "lint": lint,
        "format": format,
        "help": help_cmd,
    }

    if command in commands:
        commands[command]()
    else:
        _print_error(f"Unknown command: {command}")
        print("\nRun 'poetry run help' to see available commands.")
        sys.exit(1)
